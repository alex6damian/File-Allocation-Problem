\usepackage[romanian]{babel}

\section{Introducere}

În contextul actual al sistemelor de calcul, arhitecturile distribuite au devenit standardul pentru gestionarea volumelor mari de date și a sarcinilor computaționale complexe. Un sistem distribuit poate fi definit ca o colecție de agenți de calcul interconectați care partajează resurse pentru a îndeplini sarcini comune (``In the broadest sense, a distributed computer system can be thought of simply as a set of interconnected computing agents which require the use of certain system resources in order to perform their assigned tasks''). Deși partajarea resurselor aduce beneficii semnificative în termeni de performanță și fiabilitate, aceasta introduce o provocare fundamentală de proiectare: dezvoltarea unor mecanisme eficiente și robuste pentru alocarea și accesul la aceste resurse (``Since significant benefits can often be realized by sharing these system resources among the distributed agents, a principal challenge in the area of distributed system design is the development of efficient and robust resource allocation and access mechanisms'').

Acest proiect abordează \textbf{Problema Alocării Fișierelor (File Allocation Problem - FAP)}, o problemă clasică de optimizare în sistemele distribuite. În esență, problema constă în a determina modul optim de distribuire a unei resurse divizibile (precum un fișier de mari dimensiuni sau o bază de date) pe un set de noduri disponibile în rețea (``Simply stated, the file allocation problem addresses the question of how the file or file system should be allocated among the nodes in a distributed system in order to 'optimize' system performance''). Obiectivul este de a maximiza performanța globală a sistemului, măsurată de obicei prin minimizarea unui cost total.

Alocarea resurselor implică un compromis (trade-off) între doi factori critici, care adesea dictează strategii opuse (``Interestingly, each of these two costs, considered alone, suggest diametrically opposed allocation strategies''):
\begin{itemize}
    \item \textbf{Costul de comunicare:} Pentru a minimiza traficul de rețea, strategia ideală ar fi plasarea resursei integral pe nodul care o solicită cel mai frecvent sau pe un nod central cu conectivitate optimă (``If communication is the sole cost, the optimal strategy is simply to put the entire resource at that node i where $C_{i}$ is minimal'').
    \item \textbf{Timpul de procesare (întârzierea):} Concentrarea resursei pe un singur nod poate duce la formarea unor cozi de așteptare mari și la congestionarea procesorului respectiv, crescând timpul mediu de răspuns. Din acest punct de vedere, strategia ideală ar fi distribuirea uniformă a resursei pe toate nodurile pentru a echilibra încărcarea (load balancing) (``However, concentrating a large amount of a resource at one node means that a correspondingly large number of queries will be directed to that node with resulting large access delays. This would argue for distributing the resource evenly among the n network nodes'').
\end{itemize}

Proiectul de față propune și analizează o abordare \textbf{microeconomică} pentru rezolvarea acestei probleme (``Our algorithms have their origins in the field of mathematical economics''). În acest model, nodurile sistemului sunt tratate ca agenți economici într-o piață, care iau decizii de alocare bazate pe "utilitatea marginală" a resursei. Spre deosebire de abordările centralizate, care pot deveni puncte unice de eșec și scalează greu (``First, an inherent drawback in any nondistributed scheme is that of reliability, since a single central agent represents a critical point-of-failure in the network... Second, a centralized approach towards optimization ignores the distributed computational power inherent in the network''), algoritmii descentralizați implementați în această lucrare permit nodurilor să negocieze și să migreze fracțiuni din resursă ("colete" de date) pentru a atinge un echilibru optim global, minimizând atât latența de procesare, cât și costurile de transport (``These algorithms are shown to have several attractive features including their simplicity, distributed nature, provable (and rapid) convergence, and the computation of successively better resource allocations at each step'').





\section{Descrierea Algoritmului Serial}

Pentru a putea dezvolta o soluție distribuită, este necesară mai întâi definirea formală a modelului matematic și a modului în care problema ar fi rezolvată într-o manieră centralizată (serială). În această abordare simplificată, presupunem existența unui singur agent de calcul care deține toate informațiile despre starea rețelei și care execută optimizarea pentru întregul sistem.

\subsection{Definirea Parametrilor și Notații}
Modelul matematic utilizat se bazează pe parametrii definiți în lucrarea de referință a lui Kurose și Simha. Considerăm o rețea formată din $N$ noduri, caracterizată de următoarele variabile:

\begin{itemize}
    \item $\lambda$: Rata totală de sosire a cererilor în sistem (``The networkwide access generation rate is defined, $\lambda=\Sigma_{i=1}^{n}\lambda_{i}$'' [cite: 112]). Aceasta reprezintă intensitatea globală a traficului care trebuie procesat.
    
    \item $\mu$: Rata medie de servire a unui nod. Se modelează timpul de servire ca o variabilă aleatoare exponențială (``We model the service requirements of each access as an exponential random variable with mean $1/\mu$'' [cite: 131]).
    
    \item $x_i$: Fracțiunea din resursa totală (fișier) alocată nodului $i$ (``$x_i$ the fraction of the file resource stored at node i'' [cite: 132]). Deoarece resursa este unică și divizibilă, suma fracțiunilor trebuie să fie unitară: $\sum_{i=1}^{N} x_i = 1$.
    
    \item $C_i$: Costul mediu de comunicare pentru a accesa o porțiune de fișier stocată pe nodul $i$ (``$C_{i}$ the average (systemwide) communication cost of making an access at node i'' [cite: 126]).
\end{itemize}

\subsection{Funcția de Cost Global}
Performanța sistemului nu depinde doar de viteza rețelei, ci și de capacitatea de procesare a nodurilor. Timpul de așteptare la un nod este modelat folosind teoria cozilor (modelul M/M/1), unde întârzierea este invers proporțională cu capacitatea rămasă neutilizată:
\begin{equation}
    T_i = \frac{1}{\mu - \lambda x_i}
\end{equation}
(``This provides a formula for the long-term average delay at node i, as a function of $x_i$'' [cite: 140]).

Astfel, problema optimizării poate fi formulată matematic prin funcția de cost global, care însumează costurile fiecărui nod ponderate cu fracțiunea de resursă deținută:

\begin{equation}
    C = \sum_{i=1}^{N} \left( C_i + \frac{K}{\mu - \lambda x_i} \right) x_i
\end{equation}

În această ecuație, $K$ este o constantă de ponderare care reglează importanța relativă a întârzierii (timpul de răspuns) față de costul comunicării (``In our overall cost function, the relative importance of communication costs and access delays will be characterized by the constant K'' [cite: 147]).

Obiectivul algoritmului este minimizarea valorii $C$, respectând constrângerile de stabilitate ($\mu > \lambda x_i$) și de fezabilitate ($\sum x_i = 1$).

\subsection{Soluția Serială și Limitări}
Un algoritm serial clasic ar aborda această problemă de optimizare neliniară într-un punct central. Un agent administrator ar colecta toți parametrii ($\lambda, \mu, C_i$) și ar calcula derivatele parțiale ale funcției de cost în raport cu $x_i$ pentru a găsi minimul global.

Deși matematic corectă, această abordare are dezavantaje majore în sistemele reale distribuite:
\begin{enumerate}
    \item \textbf{Lipsa de fiabilitate:} Agentul central reprezintă un singur punct de eșec. Dacă acesta cade, întregul proces de alocare se oprește (``First, an inherent drawback in any nondistributed scheme is that of reliability, since a single central agent represents a critical point-of-failure in the network'' [cite: 17]).
    
    \item \textbf{Ignorarea puterii de calcul distribuite:} Calculul serial nu folosește capacitatea procesoarelor din rețea, ci încarcă un singur nod cu toată munca de optimizare (``A centralized approach towards optimization ignores the distributed computational power inherent in the network'' [cite: 19]).
\end{enumerate}

Aceste limitări justifică necesitatea implementării unor algoritmi distribuiți (SPMD), descriși în secțiunea următoare.







\section{Descrierea Variantei Distribuite (SPMD)}

Pentru a transpune modelul matematic într-un sistem distribuit funcțional, am adoptat paradigma \textbf{SPMD (Single Program, Multiple Data)}. În această arhitectură, fiecare nod din rețea rulează identic același cod (același program), dar operează pe seturi de date diferite (propria rată de sosire $\lambda_i$ și propria alocare $x_i$).

În implementarea realizată în limbajul \textbf{Go}, această autonomie este simulată prin utilizarea \textit{Goroutines}. Fiecare nod este tratat ca un proces independent care comunică cu celelalte pentru a atinge echilibrul global.

\begin{lstlisting}[language=Go, caption={Structura de date a Nodului (din resource\_allocation.go)}]
type Node struct {
    ID         int
    Lambda     float64 // Rata de sosire (cereri/sec)
    Mu         float64 // Capacitatea de procesare
    Allocation float64 // x_i (Resursa detinuta)
}
\end{lstlisting}

Procesul de optimizare este iterativ. La fiecare pas, nodurile execută un ciclu compus din trei faze distincte, conform modelului teoretic (``The algorithm is iterative in nature and consists of a local computation followed by a communication step''):

\begin{enumerate}
    \item \textbf{Calcul Local:} Nodul își evaluează performanța curentă calculând utilitatea marginală ($U'_i$).
    \item \textbf{Comunicare:} Nodul schimbă informații despre derivate cu ceilalți agenți din rețea.
    \item \textbf{Actualizare (Re-alocare):} Pe baza diferențelor de utilitate, nodul își ajustează cantitatea de resursă $x_i$ (``The 'allocation' of the resource is then changed such that agents with an above average marginal utility receive more of this resource'').
\end{enumerate}

În cadrul proiectului au fost implementați trei algoritmi distincți care respectă acest ciclu, diferențiați prin modul în care calculează pasul de actualizare și prin structura comunicării.

\subsection{Algoritmul bazat pe Prima Derivată (Gradient Descent)}
Acesta este algoritmul fundamental, implementat în funcția \texttt{FirstDerivativeAlgorithm}. Fiecare nod calculează derivata întâi a funcției de cost (utilitatea marginală) folosind funcția \texttt{ComputeFirstDerivative}.

Mecanismul este următorul:
\begin{itemize}
    \item Toate nodurile trimit $U'_i$ (derivata) către un proces de agregare care calculează media globală $\overline{U'}$.
    \item Nodurile cu $U'_i > \overline{U'}$ (care au nevoie de mai multe resurse) primesc o alocare suplimentară, iar celelalte cedează resurse.
    \item Pasul de modificare este fix, controlat de parametrul $\alpha$ (``In the above algorithm, we refer to the term which scales the difference between the average marginal utility and an individual marginal utility as the stepsize parameter'').
\end{itemize}

Deși simplu, acest algoritm necesită un număr mare de iterații pentru a converge, deoarece nu ține cont de curbura funcției de cost.

\subsection{Algoritmul bazat pe a Doua Derivată (Metoda Newton)}
Pentru a accelera convergența, acest algoritm (implementat în \texttt{SecondDerivativeAlgorithm}) utilizează informații suplimentare despre "accelerația" costului.

Pe lângă derivata întâi, fiecare nod calculează și inversul derivatei a doua, notat cu $k_i$.
\begin{equation}
    k_i = \frac{1}{\frac{\partial^2 U}{\partial x_i^2}}
\end{equation}
Această valoare este calculată în cod prin funcția \texttt{Compute1onSecondDerivative}.

Avantajul major este ajustarea dinamică a pasului de învățare pentru fiecare nod în parte (``Intuitively, it should be possible to improve the convergence behavior ... by using a variable stepsize parameter that is sensitive to the current allocation and shape of the utility function''). Nodurile își scalează modificarea alocării ($\Delta x_i$) proporțional cu $k_i$, ceea ce permite o convergență mult mai rapidă și mai stabilă comparativ cu prima metodă.

\subsection{Algoritmul "Pairwise Interaction" (Interacțiune Pereche)}
Primele două metode necesită o formă de sincronizare globală pentru a calcula media derivatelor. Algoritmul Pairwise (implementat în \texttt{PairwiseAlgorithm}) elimină această dependență globală, fiind ideal pentru sisteme distribuite scalabile.

În acest model, comunicarea are loc strict între vecini, definiți printr-o topologie de rețea (``The third algorithm studied is based on localized exchange of gradient information among neighbors ... Note that the algorithm requires communication only between direct neighbors'').

\begin{lstlisting}[language=Go, caption={Actualizarea în perechi (din resource\_allocation.go)}]
// Schimb de resurse intre nodul i si nodul j
exchange := -alpha * (ki * kj) / (ki + kj) * (di - dj)
deltas[i] += exchange
deltas[j] -= exchange
\end{lstlisting}

Echilibrarea se face prin "tranzacții" bilaterale: dacă nodul $i$ are o utilitate marginală mai mare decât vecinul $j$, resursele sunt transferate de la $j$ la $i$. Procesul continuă până când diferențele dintre toți vecinii devin neglijabile, moment în care sistemul a atins echilibrul global.




// cu comentarii
\documentclass[12pt, a4paper]{article}

% --- PACHETE NECESARE ---
\usepackage[romanian]{babel}  % Setări pentru limba română
\usepackage[utf8]{inputenc}   % Encoding
\usepackage{geometry}         % Margini
\usepackage{amsmath}          % Formule matematice
\usepackage{graphicx}         % Imagini și grafice
\usepackage{hyperref}         % Link-uri și cuprins interactiv
\usepackage{listings}         % Pentru cod sursă
\usepackage{xcolor}           % Culori pentru cod
\usepackage{float}            % Poziționare figuri

% --- SETĂRI PAGINĂ ---
\geometry{left=2.5cm, right=2.5cm, top=2.5cm, bottom=2.5cm}

% --- CONFIGURARE COD SURSĂ (Go) ---
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinelanguage{Go}{
  keywords={break, default, func, interface, select, case, defer, go, map, struct, chan, else, goto, package, switch, const, fallthrough, if, range, type, continue, for, import, return, var},
  keywordstyle=\color{blue}\bfseries,
  comment=[l]{//},
  commentstyle=\color{codegreen}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}

\lstset{
    backgroundcolor=\color{backcolour},   
    basicstyle=\ttfamily\footnotesize,
    keywordstyle=\color{blue},
    commentstyle=\color{codegreen},
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    tabsize=4,
    frame=single
}

% --- DATELE PROIECTULUI ---
\title{\textbf{Abordare Microeconomică pentru Alocarea Optimă a Resurselor în Sisteme Distribuite}}
\author{
    \textbf{Studenți:} \\
    Damian Alexandru (342) \\
    Horneț Alex-Andrei (342) \\
    Opran Andrei (342) \\
    \\
    \textbf{Materie:} Sisteme Distribuite \\
    \textbf{Profesor:} Conf. Dr.\ Andrei Pătrașcu
}
\date{}

\begin{document}

\maketitle
\tableofcontents
\newpage

% =========================================================================
% 1. INTRODUCERE (Cerință: context, descriere problemă) [cite: 653]
% =========================================================================
\section{Introducere}

% TODO: Scrie aici despre Problema Alocării Fișierelor (FAP).
% Idei de atins:
% - Context: Sistemele distribuite moderne trebuie să împartă resurse (fișiere, baze de date).
% - Problema: Cum împărțim un fișier pe N noduri astfel încât să fie accesat rapid?
% - Trade-off-ul: Dacă punem totul pe un nod, crește timpul de așteptare (coada). Dacă fragmentăm prea mult, crește costul de comunicare.
% - Soluția propusă: O abordare microeconomică, unde nodurile "negociază" resursele pentru a minimiza costul global.

Arhitecturile  distribuite reprezinta solutia optima pentru gestionarea volumelor mari de date si a sarcinilor computationale complexe.
Un sistem distribuit poate fi vazut ca un set de agenti de calcul interconectati care partajeaza resurse pentru a indeplini sarcini comune.
Partajarea resurselor aduce beneficii din punct de vedere al performantei, dar necesita un sistem eficient pentru alocarea si accesul la resurse.

Proiectul nostru abordeaza \textbf{Problema Alocării Fișierelor (File Allocation Problem - FAP)}, ce consta in deteminarea unui mod optim de a imparti
o resursa divizibila (de exemplu un fisier cu dimensiune mare, sau o baza de date) pe un set de noduri. Obiectivul final este de a maximiza performanta 
sistemului distribuit, performanta fiind masurata prin minimizarea unui cost total.

In principal, procesul de alocare a resurselor trebuie sa aiba in vedere doi factori, care daca ar fi luati individual, ar rezulta in strategii opuse:
\begin{itemize}
    \item \textbf{Costul de comunicare:} Minimizarea traficului se face optim prin plasarea resursei nedivizate pe nodul care o solicita cel mai frecvent, 
    sau pe un nod central cu costul de comunicare minimal.
    \item \textbf{Timpul de procesare:} Plasarea a mai multor resurse pe un singur nod rezulta in cozi de asteptare si aglomerarea procesorului, crescand timpul
    de raspuns. Astfel, ajungem la concluzia ca trebuie sa distribuim uniform resursa pe toate nodurile.
\end{itemize}

% NOTE:
% Utilitatea marginală este răspunsul la întrebarea: „Cât de mult câștig (sau pierd) dacă mai primesc ÎNCĂ O unitate din resursă?”
% Utilitatea marginală este reprezentată matematic prin derivata parțială a funcției de cost în raport cu variabila xi​ a nodului respectiv,
% indicând contribuția specifică a acelui nod la performanța globală dacă i se modifică alocarea

In acest proiect se propune si se analizeaza o abordare \textbf{microeconomica} pentru rezolvarea problemei. Astfel, fiecare nod este considerat un agent
economic dintr-o piata, care ia decizii bazate pe impactul (costul sau beneficiul) preluarii unei cantitati de resursa. Sistemele centralizate se scaleaza
greu, si pot deveni puncte de esec. Algoritmii descentralizati din aceasta lucrare, beneficiind de resursele distribuite ale sistemului, permit nodurilor
sa negocieze si sa migreze fractiuni din resursa pentru a atinge un echilibru economic in tot setul de noduri, minimizand costul de comunicare si
timpul de procesare.

% =========================================================================
% 2. DESCRIEREA ALGORITMULUI SERIAL (Cerință: algoritm serial) [cite: 654]
% =========================================================================
\section{Descrierea Algoritmului Serial}

% TODO: Descrie modelul matematic centralizat (Cum ar rezolva un singur calculator problema).
% 1. Definește notațiile: lambda (rata sosire), mu (rata servire), x_i (fracțiunea alocată).
% 2. Scrie formula de Cost Global (Eq 1 din PDF-ul teoriei):
%    C = Suma( (Ci + K / (mu - lambda*xi)) * xi )
% 3. Explică faptul că un algoritm serial ar calcula derivatele parțiale pentru toate nodurile și ar rezolva sistemul de ecuații centralizat.


Pentru a descrie algoritmul serial, presupunem ca avem un agent de calcul care executa optimizarea pentru intregul sistem, avand acces la toate
informatiile despre starea retelei.

\subsection{Definirea Parametrilor}
Algoritmul utilizat este bazat pe cel din lucrarea scrisa de Kurose si Simha. Consideram un sistem format din \(N\) noduri, cu urmatoarele variabile:

\begin{itemize}
    \item $\lambda$: Rata totala de sosire a cererilor in sistem, reprezentand intensitatea globala a traficului care trebuie procesat 
    ($\lambda=\Sigma_{i=1}^{n}\lambda_{i}$).
    
    \item $\mu$: Rata medie de servire a unui nod. Timpul de servire se modeleaza ca fiind o variabile aleatoare exponentiala cu media $1/\mu$.
    
    \item $x_i$: Cantitatea de resursa alocata nodului $i$, din totalitatea de resurse a intregului sistem. Suma cantitatilor alocate tuturor
    nodurilor este unitara, deoarece resursa este unica ($\sum_{i=1}^{N} x_i = 1$).
    
    \item $C_i$: Costul mediu de comunicare pentru a accesa resursa stocata pe nodul $i$.
\end{itemize}

\subsection{Functia de Cost Global}

Performanta sistemului depinde de viteza comunicarii intre noduri si capacitatea de procesare a fiecarui nod. Timpul de asteptare la un nod este
aratat de modelul M/M/1 din teoria cozilor (sosiri aleatoare tip Poisson, timpi de servire cu distribuire exponentiala si un
singur procesor de deservire pe fiecare nod). Intarzierea este inversul capacitatii neutilizate a sistemului, valoarea sa formandu-se in functie de $x_i$:
\begin{equation}
    T_i = \frac{1}{\mu - \lambda x_i}
\end{equation}

Definim mai jos functia de cost global, reprezentand baza problemei de optimizare, ce insumeaza costurile fiecarui nod ponderate cu cantitatea de 
resursa detinuta de nodul respectiv:

\begin{equation}
    C = \sum_{i=1}^{N} \left( C_i + \frac{K}{\mu - \lambda x_i} \right) x_i
\end{equation}

In ecuatia de cost global, importanta relativa dintre timpul de raspuns si costul de comunicare este caracterizata de constanta de ponderare $K$.

Obiectivul algoritmului este minimizarea valorii $C$, luand in considerare $\mu > \lambda x_i$ si $\sum x_i = 1$.

\subsection{Limitarile Algormitmului Serial}

Prespunem existenta unui nod central ce are acces la toti parametrii sistemului ($\lambda, \mu, C_i$) si care calculeaza derivatele partiale ale functiei de cost in raport
cu $x_i$ pentru a gasi minimul global.

Aceasta abordare aduce rezultatele dorite, insa avem urmatoarele dezavantaje in contextul sistemelor distribuite:

\begin{enumerate}
    \item \textbf{Lipsa de siguranta:} Daca nodul central se defectioneaza, intregul proces de alocare din sistem nu ma poate functiona.
    
    \item \textbf{Ignorarea puterii de calcul distribuite:} Calculul serial nu foloseste capacitatea computationala a intregului sistem, ci incarca un singur nod cu 
    munca de optimizare
\end{enumerate}


% =========================================================================
% 3. DESCRIEREA VARIANTEI DISTRIBUITE (SPMD) [cite: 655]
% =========================================================================
\section{Descrierea Variantei Distribuite (SPMD)}

% TODO: Explică transformarea în algoritm distribuit.
% - Modelul SPMD (Single Program, Multiple Data): Fiecare nod rulează același cod (structura Node din Go).
% - Descrie pașii unei iterații:
%   1. Calcul Local: Fiecare nod își calculează Utilitatea Marginală (Derivata I) și, opțional, factorul de scalare (Derivata II).
%   2. Comunicare: Schimb de mesaje (Broadcast sau Pairwise) pentru a afla starea celorlalți.
%   3. Actualizare: Ajustarea variabilei locale x_i.

% Aici poți detalia cei 3 algoritmi implementați (First Derivative, Second Derivative, Pairwise).

Pentru a transpune algoritmul serial in formatul \textbf{SPMD (Single Program, Multiple Data)}, fiecare nod ruleaza acelasi cod identic, dar foloseste seturi
de date diferite (rata de sosire $\lambda_i$ si alocarea $x_i$, ambele specifice nodului respectiv)

In implementarea realizata in limbajul \textbf{Go}, simularea nodurilor se face prin intermediul a \textit{Goroutines}. Fiecare nod este tratat ca un proces
independent care comunica cu celelalte pentru a atinge un echilibru global pe intregul sistem.

\begin{lstlisting}[language=Go, caption={Structura de date a Nodului (din resource\_allocation.go)}]
type Node struct {
    ID         int
    Lambda     float64 // Rata de sosire (cereri/sec)
    Mu         float64 // Capacitatea de procesare
    Allocation float64 // x_i (Resursa detinuta)
}
\end{lstlisting}

Optimizarea sistemului se face iterativ, la fiecare pas nodurile executa un ciclu compus din trei pasi:

\begin{enumerate}
    \item \textbf{Calcul Local:} Nodul isi evalueaza performanta curenta calculand utilitatea marginala (cat de mult castiga, sau pierde, daca primeste inca o unitate din resursa, notat cu $U'_i$,).
    \item \textbf{Comunicare:} Nodul schimba informatii despre utilitatea marginala cu celelalte noduri din retea.
    \item \textbf{Actualizare:} Pe baza diferentelor de utilitate, nodul isi modifica cantitatea de resursa $x_i$.
    Astfel, nodurile cu o utilitate marginala peste medie primesc mai multe resurse.
\end{enumerate}

In acest proiect au fost implementati 3 algoritmi care respecta ciclul anterior mentionat, diferentele fiind in pasii de comunicare si actualizare.


\subsection{Algoritmul bazat pe Prima Derivata (Gradient Descent)}

Algoritmul bazat pe prima derivata reprezinta algoritmul fundamental, implementat in functia \texttt{FirstDerivativeAlgorithm}. Fiecare nod calculeaza
prima derivata a functiei de cost, echivalenta cu utilitatea marginala, folosind functia \texttt{ComputeFirstDerivative}, ce are urmatorul flux de lucru:

\begin{itemize}
    \item Toate nodurile trimit $U'_i$ (derivata) catre un proces de agregare care calculeaza media globala $\overline{U'}$.
    \item Nodurile care au $U'_i > \overline{U'}$ reprezinta nodurile care au nevoie de mai multe resurse, si primesc o alocare suplimentara,
    iar celelalte nodurile care au $U'_i < \overline{U'}$ cedeaza resurse.
    \item Pasul de modificare este fixat si reglat de catre parametrul $\alpha$, modificarea referindu-se la diferenta dintre utilitatea marginala medie
    si utilitatea marginala a unui nod $x_i$.
\end{itemize}

Acest algoritm nu tine cont de curbura functiei de cost, astfel necesita un numar mare de iteratii pentru a converge.



\subsection{Algoritmul bazat pe a Doua Derivata (Metoda Newton)}

Algoritmul bazat pe a doua derivata, implementat in \texttt{SecondDerivativeAlgorithm}, utilizeaza informatii suplimentare despre acceleratia costului pentru a accelera convergenta.

Pe langa derivata intai, fiecare nod calculeaza si inversul derivatei a doua, notata cu $k_i$.

\begin{equation}
    k_i = \frac{1}{\frac{\partial^2 U}{\partial x_i^2}}
\end{equation}

Aceasta valoare este calculata in cod prin functia \texttt{Compute1onSecondDerivative}.

Avantajul acestui algoritm fata de cel precedent este ajustarea dinamica a pasului de invatare pentru fiecare nod. Nodurile isi scaleaza modificarea
alocarii ($\Delta x_i$) proportional cu $k_i$, ceea ce permite o convergenta mult mai rapida.

\subsection{Algoritmul Pairwise Interaction}

Primii doi algoritmi prezentati necesita o forma de sincronizare gloabala a retelei pentru a calcula media derivatelor, ceea ce ingreuneaza
scalabilitatea. Algoritmul Pairwise Interaction, implementat in \texttt{PairwiseAlgorithm}, elimina aceasta sincronizare, ceea ce faciliteaza scalabilitate.

Comunicarea se face stric intre vecini, definiti printr-o topologie de retea.

\begin{lstlisting}[language=Go, caption={Actualizarea in perechi (din resource\_allocation.go)}]
// Schimb de resurse intre nodul i si nodul j
exchange := -alpha * (ki * kj) / (ki + kj) * (di - dj)
deltas[i] += exchange
deltas[j] -= exchange
\end{lstlisting}

Echilibrarea se face prin tranzactii bilaterale: daca nodul $i$ are o utilitate marginala mai mare decat venicul $j$, resursele sunt transferate de
la $j$ la $i$, si viceversa. Sistemul atinge echilibrul global in momentul in care diferentele dintre utilitati sunt neglijabile.


% =========================================================================
% 4. ANALIZĂ TEORETICĂ ȘI DISCUȚII [cite: 656]
% =========================================================================
\section{Analiză Teoretică și Discuții}

% 4.1 Corectitudine [cite: 657]
\subsection{Analiza Corectitudinii}
% TODO: Discută premisele (ex: funcția de cost convexă).
% Menționează proprietățile de Fezabilitate (suma x_i rămâne 1) și Monotonie (costul scade mereu).

% 4.2 Complexitate [cite: 658]
\subsection{Analiza Complexității}
% TODO:
% - Algoritm 1 & 2: Necesită coordonare globală (O(N) mesaje per iterație sau broadcast).
% - Algoritm Pairwise: Comunicare locală (O(1) per pereche), dar convergență posibil mai lentă în număr de pași.

% 4.3 Scalabilitate (Avantaje/Dezavantaje) [cite: 659]
\subsection{Variația Numărului de Noduri și Scalabilitate}
% TODO: Discută ce se întâmplă când N crește.
% Pairwise este mai scalabil pentru N mare. Newton (Alg 2) e rapid pentru N mic/mediu.

% 4.4 Exemple Topologii [cite: 659]
\subsection{Exemplificare pe Topologii}
% TODO: Adaugă graficele generate sau screenshot-uri din consolă.
% Compară rezultatele pentru topologia Fully Connected vs. Ring (sau ce ai testat în Pairwise).

\begin{figure}[H]
    \centering
    % \includegraphics[width=0.8\textwidth]{grafic_convergenta.png}
    \caption{Evoluția costului global în funcție de iterații pentru cei 3 algoritmi.}
\end{figure}


% =========================================================================
% 5. CONCLUZII
% =========================================================================
\section{Concluzii}
% TODO: Sumarizează ce ai demonstrat (Algoritmul 2 e cel mai rapid, Pairwise e cel mai robust).


% =========================================================================
% BIBLIOGRAFIE
% =========================================================================
\begin{thebibliography}{9}
\bibitem{kurose}
  J. F. Kurose și R. Simha,
  \textit{A Microeconomic Approach to Optimal Resource Allocation in Distributed Computer Systems},
  IEEE Transactions on Computers, Vol. 38, No. 5, May 1989.

\bibitem{implementare}
  Sursă cod proiect: \texttt{Implementation/resource\_allocation.go}.
\end{thebibliography}

\end{document}