\documentclass[12pt, a4paper]{article}

% --- PACHETE NECESARE ---
\usepackage[romanian]{babel}  % Setări pentru limba română
\usepackage[utf8]{inputenc}   % Encoding
\usepackage{geometry}         % Margini
\usepackage{amsmath}          % Formule matematice
\usepackage{graphicx}         % Imagini și grafice
\usepackage{hyperref}         % Link-uri și cuprins interactiv
\usepackage{listings}         % Pentru cod sursă
\usepackage{xcolor}           % Culori pentru cod
\usepackage{float}            % Poziționare figuri

% --- SETĂRI PAGINĂ ---
\geometry{left=2.5cm, right=2.5cm, top=2.5cm, bottom=2.5cm}

% --- CONFIGURARE COD SURSĂ (Go) ---
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinelanguage{Go}{
  keywords={break, default, func, interface, select, case, defer, go, map, struct, chan, else, goto, package, switch, const, fallthrough, if, range, type, continue, for, import, return, var},
  keywordstyle=\color{blue}\bfseries,
  comment=[l]{//},
  commentstyle=\color{codegreen}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}

\lstset{
    backgroundcolor=\color{backcolour},   
    basicstyle=\ttfamily\footnotesize,
    keywordstyle=\color{blue},
    commentstyle=\color{codegreen},
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    tabsize=4,
    frame=single
}

% --- DATELE PROIECTULUI ---
\title{\textbf{Abordare Microeconomică pentru Alocarea Optimă a Resurselor în Sisteme Distribuite}}
\author{
    \textbf{Studenți:} \\
    Damian Alexandru (342) \\
    Horneț Alex-Andrei (342) \\
    Opran Andrei (342) \\
    \\
    \textbf{Materie:} Sisteme Distribuite \\
    \textbf{Profesor:} Conf. Dr.\ Andrei Pătrașcu
}
\date{}

\begin{document}

\maketitle
\tableofcontents
\newpage

% =========================================================================
% 1. INTRODUCERE (Cerință: context, descriere problemă)
% =========================================================================
\section{Introducere}

Arhitecturile distribuite reprezintă soluția optimă pentru gestionarea volumelor mari de date și a sarcinilor computaționale complexe.
Un sistem distribuit poate fi văzut ca un set de agenți de calcul interconectați care partajează resurse pentru a îndeplini sarcini comune.
Partajarea resurselor aduce beneficii din punct de vedere al performanței, dar necesită un sistem eficient pentru alocarea și accesul la resurse.

Proiectul nostru abordează \textbf{Problema Alocării Fișierelor (File Allocation Problem - FAP)}, ce constă în determinarea unui mod optim de a împărți
o resursă divizibilă (de exemplu un fișier cu dimensiune mare, sau o bază de date) pe un set de noduri. Obiectivul final este de a maximiza performanța 
sistemului distribuit, performanța fiind măsurată prin minimizarea unui cost total.

În principal, procesul de alocare a resurselor trebuie să aibă în vedere doi factori, care dacă ar fi luați individual, ar rezulta în strategii opuse:
\begin{itemize}
    \item \textbf{Costul de comunicare:} Minimizarea traficului se face optim prin plasarea resursei nedivizate pe nodul care o solicită cel mai frecvent, 
    sau pe un nod central cu costul de comunicare minimal.
    \item \textbf{Timpul de procesare:} Plasarea a mai multor resurse pe un singur nod rezultă în cozi de așteptare și aglomerarea procesorului, crescând timpul
    de răspuns. Astfel, ajungem la concluzia că trebuie să distribuim uniform resursa pe toate nodurile.
\end{itemize}

% NOTE:
% Utilitatea marginală este răspunsul la întrebarea: „Cât de mult câștig (sau pierd) dacă mai primesc ÎNCĂ O unitate din resursă?”
% Utilitatea marginală este reprezentată matematic prin derivata parțială a funcției de cost în raport cu variabila xi​ a nodului respectiv,
% indicând contribuția specifică a acelui nod la performanța globală dacă i se modifică alocarea


În acest proiect se propune și se analizează o abordare \textbf{microeconomică} pentru rezolvarea problemei. Astfel, fiecare nod este considerat un agent
economic dintr-o piață, care ia decizii bazate pe impactul (costul sau beneficiul) preluării unei cantități de resursă. Sistemele centralizate se scalează
greu, și pot deveni puncte de eșec. Algoritmii descentralizați din această lucrare, beneficiind de resursele distribuite ale sistemului, permit nodurilor
să negocieze și să migreze fracțiuni din resursă pentru a atinge un echilibru economic în tot setul de noduri, minimizând costul de comunicare și
timpul de procesare.

% =========================================================================
% 2. DESCRIEREA ALGORITMULUI SERIAL (Cerință: algoritm serial)
% =========================================================================
\section{Descrierea Algoritmului Serial}

Pentru a descrie algoritmul serial, presupunem că avem un agent de calcul care execută optimizarea pentru întregul sistem, având acces la toate
informațiile despre starea rețelei.

\subsection{Definirea Parametrilor}
Algoritmul utilizat este bazat pe cel din lucrarea scrisă de Kurose și Simha. Considerăm un sistem format din \(N\) noduri, cu următoarele variabile:

\begin{itemize}
    \item $\lambda$: Rata totală de sosire a cererilor în sistem, reprezentând intensitatea globală a traficului care trebuie procesat 
    ($\lambda=\Sigma_{i=1}^{n}\lambda_{i}$).
    
    \item $\mu$: Rata medie de servire a unui nod. Timpul de servire se modelează ca fiind o variabilă aleatoare exponențială cu media $1/\mu$.
    
    \item $x_i$: Cantitatea de resursă alocată nodului $i$, din totalitatea de resurse a întregului sistem. Suma cantităților alocate tuturor
    nodurilor este unitară, deoarece resursa este unică ($\sum_{i=1}^{N} x_i = 1$).
    
    \item $C_i$: Costul mediu de comunicare pentru a accesa resursa stocată pe nodul $i$.
\end{itemize}

\subsection{Funcția de Cost Global}

Performanța sistemului depinde de viteza comunicării între noduri și capacitatea de procesare a fiecărui nod. Timpul de așteptare la un nod este
arătat de modelul M/M/1 din teoria cozilor (sosiri aleatoare tip Poisson, timpi de servire cu distribuție exponențială și un
singur procesor de deservire pe fiecare nod). Întârzierea este inversul capacității neutilizate a sistemului, valoarea sa formându-se în funcție de $x_i$:
\begin{equation}
    T_i = \frac{1}{\mu - \lambda x_i}
\end{equation}

Definim mai jos funcția de cost global, reprezentând baza problemei de optimizare, ce însumeaza costurile fiecărui nod ponderate cu cantitatea de 
resursă deținută de nodul respectiv:

\begin{equation}
    C = \sum_{i=1}^{N} \left( C_i + \frac{K}{\mu - \lambda x_i} \right) x_i
\end{equation}

În ecuația de cost global, importanța relativă dintre timpul de răspuns și costul de comunicare este caracterizată de constanta de ponderare $K$.

Obiectivul algoritmului este minimizarea valorii $C$, luând în considerare $\mu > \lambda x_i$ și $\sum x_i = 1$.

\subsection{Limitările Algoritmului Serial}

Presupunem existența unui nod central ce are acces la toți parametrii sistemului ($\lambda, \mu, C_i$) și care calculează derivatele parțiale ale funcției de cost în raport
cu $x_i$ pentru a găsi minimul global.

Această abordare aduce rezultatele dorite, însă avem următoarele dezavantaje în contextul sistemelor distribuite:

\begin{enumerate}
    \item \textbf{Lipsa de siguranță:} Dacă nodul central se defectează, întregul proces de alocare din sistem nu mai poate funcționa.
    
    \item \textbf{Ignorarea puterii de calcul distribuite:} Calculul serial nu folosește capacitatea computațională a întregului sistem, ci încarcă un singur nod cu 
    munca de optimizare.
\end{enumerate}


% =========================================================================
% 3. DESCRIEREA VARIANTEI DISTRIBUITE (SPMD)
% =========================================================================
\section{Descrierea Variantei Distribuite (SPMD)}

Pentru a transpune algoritmul serial în formatul \textbf{SPMD (Single Program, Multiple Data)}, fiecare nod rulează același cod identic, dar folosește seturi
de date diferite (rata de sosire $\lambda_i$ și alocarea $x_i$, ambele specifice nodului respectiv).

În implementarea realizată în limbajul \textbf{Go}, simularea nodurilor se face prin intermediul a \textit{Goroutines}. Fiecare nod este tratat ca un proces
independent care comunică cu celelalte pentru a atinge un echilibru global pe întregul sistem.

\newpage

\begin{lstlisting}[language=Go, caption={Structura de date a Nodului (din resource\_allocation.go)}]
type Node struct {
    ID         int
    Lambda     float64 // Rata de sosire (cereri/sec)
    Mu         float64 // Capacitatea de procesare
    Allocation float64 // x_i (Resursa detinuta)
}
\end{lstlisting}

Optimizarea sistemului se face iterativ, la fiecare pas nodurile execută un ciclu compus din trei pași:

\begin{enumerate}
    \item \textbf{Calcul Local:} Nodul și evaluează performanța curentă calculând utilitatea marginală (cât de mult câștigă, sau pierde, dacă primește încă o unitate din resursă, notat cu $U'_i$).
    \item \textbf{Comunicare:} Nodul schimbă informații despre utilitatea marginală cu celelalte noduri din rețea.
    \item \textbf{Actualizare:} Pe baza diferențelor de utilitate, nodul și modifică cantitatea de resursă $x_i$.
    Astfel, nodurile cu o utilitate marginală peste medie primesc mai multe resurse.
\end{enumerate}

În acest proiect au fost implementați 3 algoritmi care respectă ciclul anterior menționat, diferențele fiind în pașii de comunicare și actualizare.


\subsection{Algoritmul bazat pe Prima Derivată (Gradient Descent)}

Algoritmul bazat pe prima derivată reprezintă algoritmul fundamental, implementat în funcția \texttt{FirstDerivativeAlgorithm}. Fiecare nod calculează
prima derivată a funcției de cost, echivalentă cu utilitatea marginală, folosind funcția \texttt{ComputeFirstDerivative}, ce are următorul flux de lucru:

\begin{itemize}
    \item Toate nodurile trimit $U'_i$ (derivata) către un proces de agregare care calculează media globală $\overline{U'}$.
    \item Nodurile care au $U'_i > \overline{U'}$ reprezintă nodurile care au nevoie de mai multe resurse, și primesc o alocare suplimentară,
    iar celelalte noduri care au $U'_i < \overline{U'}$ cedează resurse.
    \item Pasul de modificare este fixat și reglat de către parametrul $\alpha$, modificarea referindu-se la diferența dintre utilitatea marginală medie
    și utilitatea marginală a unui nod $x_i$.
\end{itemize}

Acest algoritm nu ține cont de curbura funcției de cost, astfel necesită un număr mare de iterații pentru a converge.



\subsection{Algoritmul bazat pe a Doua Derivată (Metoda Newton)}

Algoritmul bazat pe a doua derivată, implementat în \texttt{SecondDerivativeAlgorithm}, utilizează informații suplimentare despre accelerația costului pentru a accelera convergența.

Pe lângă derivata întâi, fiecare nod calculează și inversul derivatei a doua, notată cu $k_i$.

\begin{equation}
    k_i = \frac{1}{\frac{\partial^2 U}{\partial x_i^2}}
\end{equation}

Această valoare este calculată în cod prin funcția \texttt{Compute1onSecondDerivative}.

Avantajul acestui algoritm față de cel precedent este ajustarea dinamică a pasului de învățare pentru fiecare nod. Nodurile și scaleaza modificarea
alocării ($\Delta x_i$) proporțional cu $k_i$, ceea ce permite o convergență mult mai rapidă.

\subsection{Algoritmul Pairwise Interaction}

Primii doi algoritmi prezentați necesită o formă de sincronizare globală a rețelei pentru a calcula media derivatelor, ceea ce îngreunează
scalabilitatea. Algoritmul Pairwise Interaction, implementat în \texttt{PairwiseAlgorithm}, elimină această sincronizare, ceea ce facilitează scalabilitate.

Comunicarea se face strict între vecini, definiți printr-o topologie de rețea.

\begin{lstlisting}[language=Go, caption={Actualizarea în perechi (din resource\_allocation.go)}]
// Schimb de resurse intre nodul i si nodul j
exchange := -alpha * (ki * kj) / (ki + kj) * (di - dj)
deltas[i] += exchange
deltas[j] -= exchange
\end{lstlisting}

Echilibrarea se face prin tranzacții bilaterale: dacă nodul $i$ are o utilitate marginală mai mare decât vecinul $j$, resursele sunt transferate de
la $j$ la $i$, și viceversa. Sistemul atinge echilibrul global în momentul în care diferențele dintre utilități sunt neglijabile.


% =========================================================================
% 4. ANALIZĂ TEORETICĂ ȘI DISCUȚII
% =========================================================================
\section{Analiză Teoretică și Discuții}

În această secțiune explicăm cum funcționează cei trei algoritmi pe care i-am implementat și cum suntem siguri că sunt corecți. Analizăm și cum se comportă sistemul când crește numărul de noduri.

\subsection{Analiza Corectitudinii}

\textbf{Funcția de cost pe care o folosim în cod.}
În implementare, costul total se calculează diferit față de formula teoretică. În loc să fie ponderat cu $x_i$, costul se calculează ținând cont de traficul fiecărui nod:
\[
C = \sum_{i=1}^{N} \left(C_i + K \cdot T_i\right)\lambda_i,
\quad \text{unde}\quad
T_i = \frac{1}{\mu - (\sum_{j=1}^{N}\lambda_j)\cdot x_i}.
\]
Costul de comunicare pentru fiecare nod este fixat la:
\[
C_i = 0.5,
\]
iar pentru a evita probleme, ne asigurăm că fiecare nod funcționează bine prin condiția:
\[
\mu - (\sum_j \lambda_j) x_i > 0.01.
\]
Dacă această condiție nu e îndeplinită, sistemul e instabil și costul devine foarte mare.

\textbf{Verificarea că resursele sunt distribuite corect: $\sum x_i = 1$ și $x_i>0$.}
După fiecare iterație, alocările sunt ajustate în doi pași:
\begin{itemize}
    \item Pe fiecare nod limităm alocarea în intervalul $[0.001, 0.90]$ pentru a evita alocări prea mici sau prea mari;
    \item Apoi normalizăm toate valorile împărțind la suma lor, pentru a ne asigura că $\sum_{i=1}^{N}x_i = 1$.
\end{itemize}
Aceasta garantează că resursa totală se conservă și niciun nod nu rămâne fără resurse.

\textbf{Cum verificăm că algoritmul a ajuns la echilibru.}
Pentru toți cei trei algoritmi, folosim același prag:
\[
\varepsilon = 10^{-5}.
\]
\begin{itemize}
  \item Pentru \textbf{Prima Derivată}: calculăm media $\overline{d}$ a derivatelor tuturor nodurilor, și spunem că am convergit dacă diferența cea mai mare dintre un nod și medie e mai mică decât pragul:
  \[
  \max_i |d_i - \overline{d}| < \varepsilon.
  \]
  \item Pentru \textbf{A Doua Derivată}: calculăm o medie ponderată cu factorii $k_i$, și ne gândim la convergență similar:
  \[
  \max_i |d_i - \overline{d}_w| < \varepsilon.
  \]
  \item Pentru \textbf{Pairwise}: fiecare nod se compară doar cu vecinii lui. Convergența e atinsă când pentru fiecare pereche de vecini $(i,j)$:
  \[
  |d_i - d_j| < \varepsilon.
  \]
\end{itemize}

\textbf{Care sunt derivatele pe care le calculăm.}
Când spunem „prima derivată", aceasta reprezintă de fapt utilitatea marginală a unui nod:
\[
d_i \equiv \frac{dU}{dx_i} = \frac{K \cdot \lambda_i \cdot (\sum_j \lambda_j)}{(\mu - (\sum_j\lambda_j)x_i)^2}.
\]
Pentru algoritmii care folosesc și informație despre curbură (a doua derivată și pairwise), calculăm:
\[
\frac{d^2U}{dx_i^2} =
\frac{2K\lambda_i(\sum_j\lambda_j)^2}{(\mu-(\sum_j\lambda_j)x_i)^3},
\quad
k_i = \frac{1}{d^2U/dx_i^2},
\]
dar avem grijă ca $k_i$ să nu devină prea mare (mai mare decât 5.0), pentru a evita pași de actualizare prea brutali.

\subsection{Analiza Complexității}

Sistemul are $N$ noduri. Deși calculele pe noduri sunt făcute în paralel cu goroutines, numărul de operații crește cu $N$.

\textbf{Cât calcul face fiecare nod pe iterație.}
Pentru fiecare nod:
\begin{itemize}
  \item în algoritmul 1: calculăm doar $d_i$ (o formulă simplă, $O(1)$),
  \item în algoritmii 2 și 3: calculăm și $d_i$ și $k_i$ (tot $O(1)$ pe nod).
\end{itemize}
Deci pe o iterație, total la nivel de sistem e $O(N)$ operații de calcul.

\textbf{Cât comunică nodurile pe iterație.}
Deși simulăm pe o mașină locală, din perspectiva unui sistem distribuit real:
\begin{itemize}
  \item \textbf{Prima Derivată} și \textbf{A Doua Derivată} au nevoie ca toate nodurile să trimită informația lor către un punct central și apoi să primească rezultatul. Asta e $O(N)$ mesaje pentru a trimite și $O(N)$ pentru a primi.
  \item \textbf{Pairwise} este mai simplu: fiecare nod schimbă date doar cu vecinii lui. Cantitatea de comunicare depinde de cât de mulți vecini are fiecare nod.
\end{itemize}

\textbf{Ce setări folosim în cod.}
În funcția \texttt{main()} am fixat următoarele valori:
\begin{itemize}
  \item \textbf{Prima Derivată}: $\alpha = 0.01$, maxim $1500$ iterații, prag $\varepsilon=10^{-5}$;
  \item \textbf{A Doua Derivată}: $\alpha = 0.005$, maxim $1000$ iterații, prag $\varepsilon=10^{-5}$;
  \item \textbf{Pairwise}: $\alpha = 0.02$, maxim $500$ iterații, prag $\varepsilon=10^{-5}$.
\end{itemize}
Aceste numere afectează cât de repede converge algoritmul și dacă rămâne stabil.

\subsection{Variația Numărului de Noduri și Scalabilitate}

Ce se întâmplă când adaugăm mai multe noduri:
\begin{itemize}
  \item \textbf{Algoritmii cu medie globală} (prima și a doua derivată) sunt mai greu de pus în practică pe un sistem mare, pentru că la fiecare iterație toate nodurile trebuie să fie sincronizate. Aceasta este o problemă dacă e mult de comunicare în rețea.
  \item \textbf{Pairwise} nu are această problemă. Fiecare nod doar schimbă cu vecinii lui, deci sistemul se adaptează mult mai ușor la creșterea numărului de noduri. Cu toate acestea, viteza la care ajung la echilibru depinde de cât de bine sunt conectate nodurile între ele.
\end{itemize}

\subsection{Topologia Folosită în Cod}

În implementare, pentru algoritmul pairwise folosesc o topologie în care fiecare nod e conectat cu toți ceilalți:
\[
E = \{(0,1),(0,2),(0,3),(1,2),(1,3),(2,3)\},
\]
(pentru 4 noduri). Asta înseamnă că informația despre dezechilibre se răspândește rapid între orice două noduri.

Regula pe care o folosim pentru a transfera resurse între doi vecini este:
\[
\Delta x_i = -\alpha \cdot \frac{k_i k_j}{k_i + k_j}\cdot (d_i - d_j),
\quad
\Delta x_j = -\Delta x_i,
\]
după care limităm valorile și le normalizăm cum am explicat mai sus.

\subsection{Rezultate Experimentale}

Pentru a verifica teoria, am rulat toți trei algoritmi și am analizat rezultatele. Graficele de mai jos arată cum se comportă fiecare algoritm.

\subsubsection{Convergența Algoritmilor}

\begin{figure}[H]
\centering
\includegraphics[width=1\textwidth]{Implementation/plots/convergence.png}
\caption{Evoluția costului total pe parcursul iterațiilor pentru cei trei algoritmi. 
Algoritmul Pairwise converge cel mai rapid (sub 50 iterații), urmat de Algoritmul pe A Doua Derivată 
(aproximativ 200 iterații). Algoritmul pe Prima Derivată este cel mai lent, necesitând 
mai mult de 1000 iterații pentru a atinge echilibru. Această comportare confirmă analiza teoretică 
că metodele cu informație de curbură sunt mai eficiente.}
\label{fig:convergence}
\end{figure}

\subsubsection{Distribuția Resurselor pe Noduri}

\begin{figure}[H]
\centering
\includegraphics[width=1\textwidth]{Implementation/plots/allocations.png}
\caption{Alocările finale de resurse pe fiecare nod după convergență. Se observă că toți trei 
algoritmi ajung la aceeași distribuție finală, ceea ce confirmă corectitudinea implementării. 
Nodul 1 primește cea mai mare parte din resurse (aproximativ 0.48), în timp ce Nodurile 0, 2 și 3 
primesc cantități mai mici, proporționale cu necesitățile lor. Diferențele minore între algoritmi 
sunt datorate toleranțelor numerice (prag $\varepsilon = 10^{-5}$).}
\label{fig:allocations}
\end{figure}

\subsubsection{Verificarea Echilibrului (Derivatele în Echilibru)}

\begin{figure}[H]
\centering
\includegraphics[width=1\textwidth]{Implementation/plots/derivatives.png}
\caption{Valorile derivatelor finale pentru fiecare nod, care verifică condiția de echilibru Nash. 
În echilibru, toți nodurile au derivate aproximativ egale (în jurul valorii 0.12), ceea ce înseamnă 
că niciun nod nu mai are incentiv să negocieze resurse cu alții. Egalitatea derivatelor este o 
condiție necesară pentru optimul global în problemele de alocare de resurse, conform teoriei 
microeconomice.}
\label{fig:derivatives}
\end{figure}


% =========================================================================
% 5. CONCLUZII
% =========================================================================
\section{Concluzii}

Am implementat și testat trei moduri diferite în care nodurile își pot ajusta alocarea de resurse. Fiecare nod calculează cât de mult ar câștiga dacă ar primi mai mult (sau ar pierde dacă ar ceda) din resurse. Cu ajutorul acestei informații, nodurile negociază și schimbă resurse până ajung la o situație în care nimeni nu mai vrea să schimbe nimic.

Toți cei trei algoritmi folosesc aceeași formulă pentru a calcula întârzierea pe fiecare nod:
\[
T_i = \frac{1}{\mu - (\sum_j\lambda_j)x_i},
\]
și o funcție de cost total:
\[
C = \sum_i (0.5 + K\cdot T_i)\lambda_i.
\]
Pentru a fi siguri că sistemul nu se defectează, ne asigurăm că $\mu-(\sum_j\lambda_j)x_i>0.01$ mereu.

Din punct de vedere practic (cum e implementat în cod):
\begin{itemize}
  \item \textbf{Algoritmul pe Prima Derivată}: fiecare nod ajustează alocarea cu un pas fix și mic ($\alpha=0.01$). E sigur și stabil, dar uneori durează mult să convergă (până la 1500 iterații).
  
  \item \textbf{Algoritmul pe A Doua Derivată}: pe lângă derivata întâi, folosim și informația despre curbură. Aceasta permite nodurilor să facă pași mai mari acolo unde e safe și pași mai mici în alte locuri. Converge mai repede decât primul (de obicei sub 1000 iterații).
  
  \item \textbf{Algoritmul Pairwise}: nodurile nu calculează o medie globală, ci doar schimbă cu vecinii. E cel mai rapid și natural pentru sisteme mari, dar viteza depinde de cum sunt conectate nodurile între ele.
\end{itemize}

Concluzia principală este că există un compromis: metodele care calculează ceva global ajung repede la echilibru, dar necesită ca toate nodurile să se sincronizeze. Metoda pairwise nu are această problemă, dar poate fi mai lentă dacă nodurile nu sunt bine conectate. Pentru sistemele mari și distribuite, metoda pairwise pare mai potrivită.


% =========================================================================
% BIBLIOGRAFIE
% =========================================================================
\begin{thebibliography}{9}
\bibitem{kurose}
  J. F. Kurose și R. Simha,
  \textit{A Microeconomic Approach to Optimal Resource Allocation in Distributed Computer Systems},
  IEEE Transactions on Computers, Vol. 38, No. 5, May 1989.

\bibitem{implementare}
  Sursă cod proiect: \texttt{Implementation/resource\_allocation.go}.
\end{thebibliography}

\end{document}